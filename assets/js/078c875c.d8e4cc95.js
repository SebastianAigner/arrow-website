"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[2394],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=s(t),m=r,h=u["".concat(p,".").concat(m)]||u[m]||d[m]||o;return t?a.createElement(h,i(i({ref:n},c),{},{components:t})):a.createElement(h,i({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},26434:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=t(87462),r=(t(67294),t(3905));const o={sidebar_position:1},i="High-level concurrency",l={unversionedId:"learn/coroutines/parallel",id:"learn/coroutines/parallel",title:"High-level concurrency",description:"Coroutines are one of the",source:"@site/content/docs/learn/coroutines/parallel.md",sourceDirName:"learn/coroutines",slug:"/learn/coroutines/parallel",permalink:"/learn/coroutines/parallel",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/coroutines/parallel.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Coroutines",permalink:"/learn/coroutines/"},next:{title:"Resource",permalink:"/learn/coroutines/resource-safety"}},p={},s=[{value:"Independently, in parallel",id:"independently-in-parallel",level:2},{value:"Flows",id:"flows",level:3},{value:"Racing",id:"racing",level:2},{value:"Integration with typed errors",id:"integration-with-typed-errors",level:2},{value:"Cancellation on Raise",id:"cancellation-on-raise",level:3},{value:"Accumulating typed errors in parallel",id:"accumulating-typed-errors-in-parallel",level:3}],c={toc:s},u="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"high-level-concurrency"},"High-level concurrency"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/coroutines-guide.html"},"Coroutines")," are one of the\nmost interesting features of Kotlin. However, the ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/"},'"coroutines standard library"'),"\nsometimes falls short, especially when dealing with many\nsuspended computations. Arrow provides those few additional functions that have\nproven useful in Kotlin code and other programming communities."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Arrow Fx makes it easier to follow the ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/composing-suspending-functions.html#structured-concurrency-with-async"},"Structured Concurrency"),"\nrules, even when the logic grows more complex.")),(0,r.kt)("h2",{id:"independently-in-parallel"},"Independently, in parallel"),(0,r.kt)("p",null,"We often have independent computations that we want to perform in parallel.\nFor example, if we need to fetch a value from the database and download a file\nfrom another service, there's no reason why we shouldn't do them concurrently.\nWe can use ",(0,r.kt)("inlineCode",{parentName:"p"},"parZip")," (PARallel ZIP) to combine the execution of both computations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun getUser(id: UserId): User =\n  parZip(\n    { getUserName(id) },\n    { getAvatar(id) }\n  ) { name, avatar -> User(name, avatar) }\n")),(0,r.kt)("p",null,"The code above showcases how ",(0,r.kt)("inlineCode",{parentName:"p"},"parZip")," is used: we have a sequence of arguments\nrepresenting each of the computations to perform, and, at the end, one final\nblock (usually written in trailing form) that specifies what to do with the\nresults of those computations. In this case, the two arguments obtain the name\nand avatar, and the block puts them together in the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," type."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"parZip")," is essential not only for its high-level view on concurrency.\nIts implementation also takes care of the complex task of propagating exceptions\nand canceling running computations whenever one of the tasks fails.")),(0,r.kt)("p",null,"In the code above, we had a fixed sequence of computations to perform in parallel.\nIn other cases, those computations depend on some form of ",(0,r.kt)("em",{parentName:"p"},"collection"),"; for example,\nwe want to obtain the name of all a user's friends. Arrow provides ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," (PARallel MAP)\nfor that use case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun getFriendNames(id: UserId): List<User> =\n  getFriendIds(id).parMap { getUserName(it) }\n")),(0,r.kt)("p",null,"One potential problem with ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," is that we may have ",(0,r.kt)("em",{parentName:"p"},"too much")," concurrency\nif the amount of elements in the collection is too significant. To fight against this\nproblem, Arrow provides a version of ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," with an additional parameter that\ntells how many computations should be dispatched in parallel."),(0,r.kt)("h3",{id:"flows"},"Flows"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-fx-coroutines/arrow.fx.coroutines/par-map.html"},(0,r.kt)("inlineCode",{parentName:"a"},"parMap")),"\nfunction is also provided for ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/"},(0,r.kt)("inlineCode",{parentName:"a"},"Flow")),".\nIf the concurrency factor is more than 1, then inner flows are collected by this operator concurrently.\nWhen this factor is one, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," is identical to calling ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," on the flow."),(0,r.kt)("p",null,"Additional performance can be gained if we don't impose the same ordering on\nthe mapping output as the one in the source flow. Just call ",(0,r.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-fx-coroutines/arrow.fx.coroutines/par-map-unordered.html"},(0,r.kt)("inlineCode",{parentName:"a"},"parMapUnordered")),"\nin that case. As with ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap"),", the concurrency factor defines how many\ncomputations should be executed concurrently at most."),(0,r.kt)("h2",{id:"racing"},"Racing"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"parX")," operators describe the cases in which we are interested in the result\nof ",(0,r.kt)("em",{parentName:"p"},"every")," computation we perform. But imagine the scenario in which we want to\ndownload a file, but we try two servers simultaneously for resilience purposes. Once we get the file from one server, we're not really interested in the\nrest. This is an example of ",(0,r.kt)("strong",{parentName:"p"},"racing")," two computations."),(0,r.kt)("p",null,"Arrow provides functions that perform racing over 2 or 3 computations, with the\noption of customizing the coroutine context."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun file(server1: String, server2: String) =\n  raceN(\n    { downloadFrom(server1) },\n    { downloadFrom(server2) }\n  ).merge()\n")),(0,r.kt)("p",null,"The example above shows a typical pattern combined with ",(0,r.kt)("inlineCode",{parentName:"p"},"raceN"),".\nThe result of the function above is ",(0,r.kt)("inlineCode",{parentName:"p"},"Either<A, B>"),", with each type\ncorresponding to one branch in ",(0,r.kt)("inlineCode",{parentName:"p"},"raceN"),'. Since we have two computations that\nreturn the same type here and don\'t care which one "wins," we conflate both into\na single value.'),(0,r.kt)("h2",{id:"integration-with-typed-errors"},"Integration with typed errors"),(0,r.kt)("p",null,"Arrow's typed errors can seamlessly integrate with the Arrow Fx Coroutines operators while supporting the patterns of structured concurrency.\nThe subtleties lie in the ordering of the DSLs and how they affect the ",(0,r.kt)("em",{parentName:"p"},"cancellation")," of scopes of structured concurrency -and error handling.\nSo you must understand how cancellation works in ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/cancellation-and-timeouts.html"},"Structured Concurrency"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun logCancellation(): Unit = try {\n  println("Sleeping for 500 milliseconds ...")\n  delay(500)\n} catch (e: CancellationException) {\n  println("Sleep was cancelled early!")\n  throw e\n}\n')),(0,r.kt)("p",null,"When we nest the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," DSL inside the Arrow Fx Coroutines operators lambdas, the errors will remain ",(0,r.kt)("em",{parentName:"p"},"inside")," the lambdas. Thus, they will ",(0,r.kt)("em",{parentName:"p"},"not")," affect any of the regular behavior.\nFor example, if we compute ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," values inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"parZip"),", any occurred ",(0,r.kt)("em",{parentName:"p"},"typed error")," will not affect the other computations. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun example() {\n  val triple = parZip(\n    { either<String, Unit> { logCancellation() } },\n    { either<String, Unit> { delay(100); raise("Error") } },\n    { either<String, Unit> { logCancellation() } }\n  ) { a, b, c -> Triple(a, b, c) }\n  println(triple)\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Sleeping for 500 milliseconds ...\nSleeping for 500 milliseconds ...\n(Either.Right(kotlin.Unit), Either.Left(Error), Either.Right(kotlin.Unit))\n")),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Using typed errors with KotlinX Flow is prone to leaking the ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," DSL scope and should be used carefully.\nMore information can be found in the ",(0,r.kt)("a",{parentName:"p",href:"../../typed-errors"},"typed errors documentation"),".")),(0,r.kt)("h3",{id:"cancellation-on-raise"},"Cancellation on Raise"),(0,r.kt)("p",null,"In contrast, when we nest Arrow Fx Coroutines operators inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," DSL, the errors will be observed by Structured Concurrency.\n",(0,r.kt)("em",{parentName:"p"},"typed errors")," follow the same rules as ",(0,r.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/cancellation-and-timeouts.html"},"Structured Concurrency"),", and behave the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"CancellationException")," since they ",(0,r.kt)("em",{parentName:"p"},"short-circuit")," the computation."),(0,r.kt)("p",null,"As shown above, ",(0,r.kt)("inlineCode",{parentName:"p"},"parZip")," allows running ",(0,r.kt)("em",{parentName:"p"},"independent")," tasks in parallel. If any of the tasks fail, the other tasks will get canceled.\nThe same semantics are also guaranteed when composing ",(0,r.kt)("inlineCode",{parentName:"p"},"parZip")," with typed errors."),(0,r.kt)("p",null,"The example below shows 3 ",(0,r.kt)("inlineCode",{parentName:"p"},"task")," running in parallel, and according to the ",(0,r.kt)("inlineCode",{parentName:"p"},"task")," implementation, the ",(0,r.kt)("inlineCode",{parentName:"p"},"TaskId")," 2 will fail."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun example() {\n  val res = either {\n    parZip(\n      { logCancellation() } ,\n      { delay(100); raise("Error") },\n      { logCancellation() }\n    ) { a, b, c -> Triple(a, b, c) }\n  }\n  println(res)\n}\n')),(0,r.kt)("p",null,"In the output, we can see that tasks ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," started, but ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," ",(0,r.kt)("em",{parentName:"p"},"raised")," an error that triggered the cancellation of the other two tasks.\nAfter tasks ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"3")," are canceled, we see that the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," is returned and prints the error message."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Sleeping for 500 milliseconds ...\nSleeping for 500 milliseconds ...\nSleep was cancelled early!\nSleep was cancelled early!\nEither.Left(Error)\n")),(0,r.kt)("p",null,"Similarly, we can apply the same pattern to ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," when working with collections, where we want all tasks to be canceled if any of them fails."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun Raise<String>.failOnEven(i: Int): Unit {\n  ensure(i % 2 != 0) { delay(100); "Error" }\n  logCancellation()\n}\n\nsuspend fun example() {\n  val res = either {\n    listOf(1, 2, 3, 4).parMap { failOnEven(it) }\n  }\n  println(res)\n}\n')),(0,r.kt)("p",null,"The example transforms, or maps, every element of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable")," ",(0,r.kt)("inlineCode",{parentName:"p"},"[1, 2, 3, 4]")," in ",(0,r.kt)("em",{parentName:"p"},"parallel")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"failOnEven"),".\nSince ",(0,r.kt)("inlineCode",{parentName:"p"},"failOnEven")," raises an error when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," is even, it fails for inputs 2 and 4, and the other two coroutines are canceled."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Sleeping for 500 milliseconds ...\nSleeping for 500 milliseconds ...\nSleep was cancelled early!\nSleep was cancelled early!\nEither.Left(Error)\n")),(0,r.kt)("h3",{id:"accumulating-typed-errors-in-parallel"},"Accumulating typed errors in parallel"),(0,r.kt)("p",null,"Arrow Fx Coroutines also provides a way to accumulate errors in parallel.\nIf we want to run tasks in parallel but accumulate all errors instead of short-circuiting, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"parMapOrAccumulate"),".\nIt works the same as ",(0,r.kt)("inlineCode",{parentName:"p"},"parMap")," from our previous example, but instead of canceling the other coroutines when one fails, it accumulates the errors.\nSo no matter how many coroutines fail, all of them will run to completion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example() {\n  val res = listOf(1, 2, 3, 4)\n    .parMapOrAccumulate { failOnEven(it) }\n  println(res)\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"Sleeping for 500 milliseconds ...\nSleeping for 500 milliseconds ...\nEither.Left(NonEmptyList(Error, Error))\n")))}d.isMDXComponent=!0}}]);