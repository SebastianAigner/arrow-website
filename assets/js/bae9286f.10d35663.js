"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[9280],{56736:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var s=n(85893),i=n(11151);const a={sidebar_position:7},o="3rd-party libraries (Laws)",r={id:"ecosystem/analysis/laws",title:"3rd-party libraries (Laws)",description:"Is a library you use not compiled with Arrow Analysis? I could tell you to open an issue in their repository and convince their authors, but this is not always possible. For those cases Arrow Analysis provides a way to declare pre- and postconditions separately from the implementation, using @Law annotations. In fact, this is the way we package the analysis information related to Kotlin's stdlib.",source:"@site/content/docs/ecosystem/analysis/laws.md",sourceDirName:"ecosystem/analysis",slug:"/ecosystem/analysis/laws",permalink:"/ecosystem/analysis/laws",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/ecosystem/analysis/laws.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"ecosystemSidebar",previous:{title:"Fields and wrappers",permalink:"/ecosystem/analysis/wrappers"},next:{title:"Java support",permalink:"/ecosystem/analysis/java"}},l={},c=[{value:"Attaching laws",id:"attaching-laws",level:2},{value:"Organizing laws",id:"organizing-laws",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"3rd-party-libraries-laws",children:"3rd-party libraries (Laws)"}),"\n",(0,s.jsxs)(t.p,{children:["Is a library you use not compiled with Arrow Analysis? I could tell you to open an issue in their repository and convince their authors, but this is not always possible. For those cases Arrow Analysis provides a way to declare pre- and postconditions separately from the implementation, using ",(0,s.jsx)(t.code,{children:"@Law"})," annotations. In fact, this is the way we package the analysis information related to Kotlin's ",(0,s.jsx)(t.code,{children:"stdlib"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["It might be the case that another 4rd-party provides the Arrow Analysis information for the 3rd-party library. In that case, just include ",(0,s.jsx)(t.strong,{children:"both"})," in your project. Oftentimes the Arrow Analysis information can be included as a ",(0,s.jsx)(t.code,{children:"compileOnly"})," dependency, since it's not used at run-time. You do ",(0,s.jsx)(t.strong,{children:"not"})," have to ",(0,s.jsx)(t.code,{children:"import"})," anything extra, just use the 3rd-party library as usual."]}),"\n",(0,s.jsx)(t.h2,{id:"attaching-laws",children:"Attaching laws"}),"\n",(0,s.jsxs)(t.p,{children:["To attach information about a 3rd-party function you declare a function somewhere else (it doesn't matter where), and annotate it with ",(0,s.jsx)(t.code,{children:"@Law"}),". Its body must follow a very restrictive form: it should only contain ",(0,s.jsx)(t.code,{children:"pre"})," and ",(0,s.jsx)(t.code,{children:"post"}),", and a ",(0,s.jsx)(t.strong,{children:"single"})," call to the 3rd-party function with the arguments in the ",(0,s.jsx)(t.strong,{children:"same order"})," they appeared in the original definition."]}),"\n",(0,s.jsx)(t.p,{children:"For example, this is the way to declare that an empty list has size 0:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-kotlin",children:'import arrow.analysis.Law\n\n@Law inline fun <T> emptyListLaw(): List<T> =\n  emptyList<T>().post({ it.size == 0 }) { "empty list has size 0" }\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As a practical tip, we find useful to mark the function as ",(0,s.jsx)(t.code,{children:"inline"}),". That way you avoid the case in which you call the law instead of the function you want to decorate in the body, since inline functions cannot be recursive."]}),"\n",(0,s.jsx)(t.h3,{id:"organizing-laws",children:"Organizing laws"}),"\n",(0,s.jsxs)(t.p,{children:["If you want to define pre and post-conditions for an entire library, it's often useful to organize those by package or type. To help with this task, you can define several laws inside an ",(0,s.jsx)(t.code,{children:"object"})," marked with the ",(0,s.jsx)(t.code,{children:"@Laws"})," annotation (notice the final ",(0,s.jsx)(t.code,{children:"s"}),".)"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-kotlin",children:'import arrow.analysis.Law\nimport arrow.analysis.Laws\n\n@Laws object ListLaws {\n  @Law inline fun <T> emptyListLaw(): List<T> =\n    emptyList<T>().post({ it.size == 0 }) { "empty list has size 0" }\n  @Law inline fun <T> getLaw(index: Int): T {\n    pre(index >= 0 && index < this.size) { "index within bounds" }\n    return get(index)\n  }\n  // ... and many more!\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Note that each function must still be marked with ",(0,s.jsx)(t.code,{children:"@Law"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var s=n(67294);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);