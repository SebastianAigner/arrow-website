"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[1721],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},84322:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={description:"Working, recovering, and accumulating errors in a typed and concise way.",sidebar_position:1},o="Working with typed errors",l={unversionedId:"learn/typed-errors/working-with-typed-errors",id:"learn/typed-errors/working-with-typed-errors",title:"Working with typed errors",description:"Working, recovering, and accumulating errors in a typed and concise way.",source:"@site/content/docs/learn/typed-errors/working-with-typed-errors.md",sourceDirName:"learn/typed-errors",slug:"/learn/typed-errors/working-with-typed-errors",permalink:"/learn/typed-errors/working-with-typed-errors",draft:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/typed-errors/working-with-typed-errors.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{description:"Working, recovering, and accumulating errors in a typed and concise way.",sidebar_position:1},sidebar:"learnSidebar",previous:{title:"Typed Errors",permalink:"/learn/typed-errors/"},next:{title:"Why nullable types & Option?",permalink:"/learn/typed-errors/nullable-and-option"}},s={},p=[{value:"Concepts and types",id:"concepts-and-types",level:2},{value:"Defining the success / happy path",id:"defining-the-success--happy-path",level:2},{value:"Raising an error",id:"raising-an-error",level:2},{value:"Running and inspecting results",id:"running-and-inspecting-results",level:2},{value:"Recovering from typed errors",id:"recovering-from-typed-errors",level:2},{value:"From logical failures",id:"from-logical-failures",level:3},{value:"From exceptions",id:"from-exceptions",level:3},{value:"Accumulating errors",id:"accumulating-errors",level:2},{value:"Accumulating different computations",id:"accumulating-different-computations",level:3},{value:"Transforming errors",id:"transforming-errors",level:2},{value:"Summary",id:"summary",level:2}],d={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"working-with-typed-errors"},"Working with typed errors"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Typed errors")," refer to a technique from functional programming in which we\nmake ",(0,r.kt)("em",{parentName:"p"},"explicit")," in the signature (or ",(0,r.kt)("em",{parentName:"p"},"type"),") the potential errors that may\narise during the execution of a piece of code. This is not the case when using\nexceptions, which any documentation is not taken into account by the compiler,\nleading to a defensive mode of error handling."),(0,r.kt)("admonition",{title:"Media resources",type:"info"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://kotlindevday.com/videos/functional-error-handling-a-practical-approach-bas-de-groot/"},(0,r.kt)("em",{parentName:"a"},"Functional Error Handling - A Practical Approach"))," by Bas de Groot"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=ipF540mBG9w"},(0,r.kt)("em",{parentName:"a"},"Exception handling in Kotlin with Arrow"))," by Ramandeep Kaur"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.youtube.com/watch?v=8WdprhzmQe4"},(0,r.kt)("em",{parentName:"a"},"Por qu\xe9 no uso excepciones en mi c\xf3digo"))," by Ra\xfal Raja and ",(0,r.kt)("a",{parentName:"li",href:"https://codely.com/"},"Codely")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/@mitchellyuwono/typed-error-handling-in-kotlin-11ff25882880"},(0,r.kt)("em",{parentName:"a"},"Typed error handling in Kotlin"))," by Mitchell Yuwono"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Functional Error Handling in Kotlin")," by Riccardo Cardin (video and text): ",(0,r.kt)("a",{parentName:"li",href:"https://blog.rockthejvm.com/functional-error-handling-in-kotlin/"},"part 1"),", ",(0,r.kt)("a",{parentName:"li",href:"https://blog.rockthejvm.com/functional-error-handling-in-kotlin-part-2/"},"part 2"),", and ",(0,r.kt)("a",{parentName:"li",href:"https://blog.rockthejvm.com/functional-error-handling-in-kotlin-part-3/"},"part 3")))),(0,r.kt)("h2",{id:"concepts-and-types"},"Concepts and types"),(0,r.kt)("p",null,"In the rest of the documentation we often refer to a few concepts related to error handling."),(0,r.kt)("admonition",{title:"Logical Failure vs. Real exceptions",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We use the term ",(0,r.kt)("em",{parentName:"p"},"logical failure")," to describe a situation not deemed as successful in your domain, but that it's still within the realms of that domain.\nFor example, if you are implementing a repository for users, not finding a user for a certain query is a logical failure."),(0,r.kt)("p",{parentName:"admonition"},"In contrast to logical failures we have ",(0,r.kt)("em",{parentName:"p"},"real exceptions"),", which are problems, usually technical, which are ",(0,r.kt)("em",{parentName:"p"},"truly exceptional")," and are thus not part of our domain.\nFor example, if the connection to the database suddenly drops, or network times out, host unavailable, etcetera.\nThose cases benefit from the ",(0,r.kt)("a",{parentName:"p",href:"../../resilience/"},"resilience mechanisms")," provided by Arrow.")),(0,r.kt)("admonition",{title:"Success and failure",type:"note"},(0,r.kt)("p",{parentName:"admonition"},"When talking about error handling, we often distinguish between ",(0,r.kt)("em",{parentName:"p"},"success")," or ",(0,r.kt)("em",{parentName:"p"},"happy path"),", and ",(0,r.kt)("em",{parentName:"p"},"failure"),".\nThe former represents the case in which everything works as intended, whereas the latter represents a problem.\nDepending on the approach, the signature of the function only signals that a failure is possible,\nor additionally describes the range of problems that may arise.")),(0,r.kt)("p",null,"There are two main approaches to representing types in the signature of a function.\nFortunately, Arrow provides a ",(0,r.kt)("em",{parentName:"p"},"uniform")," API to working with all of them, which is described in the rest of this section."),(0,r.kt)("p",null,"The first approach is using a ",(0,r.kt)("em",{parentName:"p"},"wrapper type"),", in which the return type of your function\nis nested within a larger type that provides the choice of error.\nIn that way the error is represented as a ",(0,r.kt)("em",{parentName:"p"},"value"),".\nFor example, the following signature expresses that the outcome of ",(0,r.kt)("inlineCode",{parentName:"p"},"findUser")," is\nof type ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," when successful, or ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," when a logical failure is raised."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"fun findUser(id: UserId): Either<UserNotFound, User>\n")),(0,r.kt)("p",null,"The Kotlin standard library includes a few wrapper types, but they are all restricted in the information they may include.\nArrow introduces ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Ior"),", both giving the developer the choice of type of logical failures, and reflecting that choice\nas their first type parameter."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Failure"),(0,r.kt)("th",{parentName:"tr",align:null},"Simultaneous ",(0,r.kt)("br",null)," success and failure?"),(0,r.kt)("th",{parentName:"tr",align:null},"Kotlin stdlib. or Arrow?"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"A?")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"null")),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:"https://upload.wikimedia.org/wikipedia/commons/3/37/Kotlin_Icon_2021.svg",style:{height:"20px"}}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Option<A>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"None")),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:"/img/arrow-brand-icon.svg",style:{height:"20px"}}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Result<A>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Failure")," contains a ",(0,r.kt)("inlineCode",{parentName:"td"},"Throwable"),", ",(0,r.kt)("br",null)," inspection possible at runtime"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:"https://upload.wikimedia.org/wikipedia/commons/3/37/Kotlin_Icon_2021.svg",style:{height:"20px"}}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Either<E, A>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Left")," contains value of type ",(0,r.kt)("inlineCode",{parentName:"td"},"E")),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:"/img/arrow-brand-icon.svg",style:{height:"20px"}}))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Ior<E, A>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Left")," contains value of type ",(0,r.kt)("inlineCode",{parentName:"td"},"E")),(0,r.kt)("td",{parentName:"tr",align:null},"Yes, using ",(0,r.kt)("inlineCode",{parentName:"td"},"Both")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:"/img/arrow-brand-icon.svg",style:{height:"20px"}}))))),(0,r.kt)("p",null,"The second approach is describing errors as part of the ",(0,r.kt)("em",{parentName:"p"},"computation context")," of the function.\nIn that case the ability to finish with logical failures is represented by having ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<E>"),"\nbe part of the context or scope of the function. Kotlin offers two choices here: we can use\nan extension receiver or using the more modern context receivers."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Raise<UserNotFound> is extension receiver\nfun Raise<UserNotFound>.findUser(id: UserId): User\n// Raise<UserNotFound> is context receiver\ncontext(Raise<UserNotFound>) fun findUser(id: UserId): User\n")),(0,r.kt)("p",null,"Let's define a simple program that ",(0,r.kt)("em",{parentName:"p"},"raises")," a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," or returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),". We can represent this both as a value ",(0,r.kt)("inlineCode",{parentName:"p"},"Either<UserNotFound, User>"),", and as a ",(0,r.kt)("em",{parentName:"p"},"computation")," (using ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<UserNotFound>"),")."),(0,r.kt)("admonition",{title:"Two examples per code block",type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"In the examples in this document we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Either<E, A>")," as wrapper type and\n",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<E>")," as extension receiver, with the intention of the reader choosing\ntheir preferred type. Note that the same ideas and techniques apply to the\nrest of choices outlined above.")),(0,r.kt)("h2",{id:"defining-the-success--happy-path"},"Defining the success / happy path"),(0,r.kt)("p",null,"The code below shows how we define a function which ",(0,r.kt)("em",{parentName:"p"},"successfully")," returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"object UserNotFound\ndata class User(val id: Long)\n\nval user: Either<UserNotFound, User> = User(1).right()\n\nfun Raise<UserNotFound>.user(): User = User(1)\n")),(0,r.kt)("p",null,"In the case of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", since we are creating a ",(0,r.kt)("em",{parentName:"p"},"value")," (note the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"val"),") we need to additionally wrap our value in the type that represents success.\nThis type is called ",(0,r.kt)("inlineCode",{parentName:"p"},"Right"),", although it's common to use the ",(0,r.kt)("inlineCode",{parentName:"p"},".right()")," extension function to give more predominance to the value itself.\nIn the case of a ",(0,r.kt)("em",{parentName:"p"},"computation")," (note the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"fun"),") with ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," the value is returned directly."),(0,r.kt)("h2",{id:"raising-an-error"},"Raising an error"),(0,r.kt)("p",null,"To create a ",(0,r.kt)("em",{parentName:"p"},"value")," of a ",(0,r.kt)("em",{parentName:"p"},"logical failure"),", we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"left")," ",(0,r.kt)("em",{parentName:"p"},"smart-constructor")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," DSL function for a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," inside a ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," ",(0,r.kt)("em",{parentName:"p"},"computation"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val error: Either<UserNotFound, User> = UserNotFound.left()\n\nfun Raise<UserNotFound>.error(): User = raise(UserNotFound)\n")),(0,r.kt)("p",null,"Besides ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"left"),", several DSLs are also available to check invariants.\n",(0,r.kt)("inlineCode",{parentName:"p"},"either { }")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," offer ",(0,r.kt)("inlineCode",{parentName:"p"},"ensure")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ensureNotNull"),", in spirit with ",(0,r.kt)("inlineCode",{parentName:"p"},"require")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"requireNotNull")," from the Kotlin Std.\nInstead of throwing an exception, they result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," with the given error if the predicate is not satisfied."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ensure")," takes a ",(0,r.kt)("em",{parentName:"p"},"predicate")," and a ",(0,r.kt)("em",{parentName:"p"},"lazy")," ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," value. When the ",(0,r.kt)("em",{parentName:"p"},"predicate")," is not matched, the ",(0,r.kt)("em",{parentName:"p"},"computation")," will result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),".\nIn the function below, we show how we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ensure")," to check if a given ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," has a valid id, and if not, we return a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class UserNotFound(val message: String)\n\nfun User.isValid(): Either<UserNotFound, Unit> = either {\n  ensure(id > 0) { UserNotFound("User without a valid id: $id") }\n}\n\nfun Raise<UserNotFound>.isValid(user: User): User {\n  ensure(user.id > 0) { UserNotFound("User without a valid id: ${user.id}") }\n  return user\n}\n\nfun example() {\n  User(-1).isValid() shouldBe UserNotFound("User without a valid id: -1").left()\n\n  fold(\n    { isValid(User(1)) },\n    { _: UserNotFound -> fail("No logical failure occurred!") },\n    { user: User -> user.id shouldBe 1 }\n  )\n}\n')),(0,r.kt)("p",null,"Without context receivers, these functions look pretty different depending on if we use ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Either"),". This is because we sacrifice our ",(0,r.kt)("em",{parentName:"p"},"extension receiver")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),".\nAnd thus, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," based computation cannot be an extension function on ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),". With context receivers, we could've defined it as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'context(Raise<UserNotFound>)\nfun User.isValid(): Unit =\n  ensure(id > 0) { UserNotFound("User without a valid id: $id") }\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ensureNotNull")," takes a ",(0,r.kt)("em",{parentName:"p"},"nullable value")," and a ",(0,r.kt)("em",{parentName:"p"},"lazy")," ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound")," value. When the value is null, the ",(0,r.kt)("em",{parentName:"p"},"computation")," will result in a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),".\nOtherwise, the value will be ",(0,r.kt)("em",{parentName:"p"},"smart-casted")," to non-null, and you can operate on it without checking nullability.\nIn the function below, we show how we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"ensureNotNull")," to check if a given ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," is non-null, and if not, we return a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun process(user: User?): Either<UserNotFound, Long> = either {\n  ensureNotNull(user) { UserNotFound("Cannot process null user") }\n  user.id // smart-casted to non-null\n}\n\nfun Raise<UserNotFound>.process(user: User?): Long {\n  ensureNotNull(user) { UserNotFound("Cannot process null user") }\n  return user.id // smart-casted to non-null\n}\n\nfun example() {\n  process(null) shouldBe UserNotFound("Cannot process null user").left()\n\n  fold(\n    { process(User(1)) },\n    { _: UserNotFound -> fail("No logical failure occurred!") },\n    { i: Long -> i shouldBe 1L }\n  )\n}\n')),(0,r.kt)("h2",{id:"running-and-inspecting-results"},"Running and inspecting results"),(0,r.kt)("p",null,"We ",(0,r.kt)("em",{parentName:"p"},"inspect")," the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"res")," using Kotlin's ",(0,r.kt)("inlineCode",{parentName:"p"},"when"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," the ",(0,r.kt)("em",{parentName:"p"},"computation")," providing a lambda for both the ",(0,r.kt)("em",{parentName:"p"},"logical failure")," and the ",(0,r.kt)("em",{parentName:"p"},"success")," case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  when (error) {\n    is Left -> error.value shouldBe UserNotFound\n    is Right -> fail("A logical failure occurred!")\n  }\n\n  fold(\n    block = { error() },\n    recover = { e: UserNotFound -> e shouldBe UserNotFound },\n    transform = { _: User -> fail("A logical failure occurred!") }\n  )\n}\n')),(0,r.kt)("admonition",{title:"Fold over all possible cases",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Unless you explicitly wrap your code to catch exceptions as part of ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),", exceptions bubble up in the usual way. If you need to handle those exceptions, ",(0,r.kt)("inlineCode",{parentName:"p"},"fold")," is also available with a ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," argument to recover from any ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," that might've been thrown. ",(0,r.kt)("a",{parentName:"p",href:"#from-exceptions"},"More information can be found below"),".")),(0,r.kt)("p",null,"Another possibility is to have a ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," computation, that we would like to turn into a wrapper type.\nIn that case we don't have to call ",(0,r.kt)("inlineCode",{parentName:"p"},"fold"),", we can use one of the runners, each of them named as the wrapper type, but with all letters in lowercase."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun example() {\n  either { error() } shouldBe UserNotFound.left()\n}\n")),(0,r.kt)("p",null,"The converse direction, turning a value of a type like ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," into a\ncomputation with ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),", is achieved via the ",(0,r.kt)("inlineCode",{parentName:"p"},".bind()")," extension function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun Raise<UserNotFound>.res(): User = user.bind()\n")),(0,r.kt)("p",null,"In fact, to define a result with a wrapper type, we recommend to use one\nof the runners (",(0,r.kt)("inlineCode",{parentName:"p"},"either"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ior"),", et cetera), and use ",(0,r.kt)("inlineCode",{parentName:"p"},".bind()"),' to "inject"\nany sub-computation that may be required, or ',(0,r.kt)("inlineCode",{parentName:"p"},"raise")," to describe a logical\nfailure. We often refer to this approach as ",(0,r.kt)("em",{parentName:"p"},"using the ",(0,r.kt)("inlineCode",{parentName:"em"},"Raise")," DSL"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val maybeTwo: Either<Problem, Int> = either { 2 }\nval maybeFive: Either<Problem, Int> = either { raise(Problem) }\n\nval maybeSeven: Either<Problem, Int> = either {\n  maybeTwo.bind() + maybeFive.bind()\n}\n")),(0,r.kt)("mermaid",{value:'graph LR;\n  raise{{"Raise&lt;E&gt;.() -> A"}};\n  other{{"WrapperType&lt;E, A&gt;"}};\n  raise--\x3e|nullable / result / either / ior|other;\n  other--\x3e|".bind()"|raise;'}),(0,r.kt)("admonition",{title:"Don't forget your binds!",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/woltapp/arrow-detekt-rules"},"Arrow Detekt Rules")," project has a set of rules to ",(0,r.kt)("em",{parentName:"p"},"detekt")," you call ",(0,r.kt)("inlineCode",{parentName:"p"},"bind")," on every ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value.")),(0,r.kt)("admonition",{title:"Nested error types",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Sometimes you may need to have one error type inside another one,\nlike ",(0,r.kt)("inlineCode",{parentName:"p"},"Either<Problem, Int?>"),". The rule of thumb in that case is to nest the\nrunner functions (",(0,r.kt)("inlineCode",{parentName:"p"},"either"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"option"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"nullable"),") in the same order as they\nappear in the type. When you call ",(0,r.kt)("inlineCode",{parentName:"p"},"raise"),', the type of the error given as\nargument is used to "select" the appropriate type to fall back to.'),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun problematic(n: Int): Either<Problem, Int?> =\n  either { \n    nullable { \n      when {\n        n < 0  -> raise(Problem)\n        n == 0 -> raise(null)\n        else   -> n\n      }\n    }\n  }\n"))),(0,r.kt)("h2",{id:"recovering-from-typed-errors"},"Recovering from typed errors"),(0,r.kt)("p",null,"We've already hinted this distinction above, but with working with type errors it's important to distinguish between two kinds of ",(0,r.kt)("em",{parentName:"p"},"problems")," that may arise:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Logical failures")," indicate problems within the domain, and which should be handled as part of the usual domain logic. For example, trying to find a user which doesn't exist, or validating input data."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"Exceptions")," indicate problems which affect the system's ability to continue working. For example, if the database connection breaks this is something outside your domain logic.")),(0,r.kt)("p",null,"Historically exceptions have been used for both cases. For example, throwing a ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotValidException")," when the input data was wrong.\nWe advocate for making this distinction clear in the types, and leave exceptions only for exceptional cases.\nHowever, we're also aware of the historical baggage, so we provide tools to transforms those exceptions which shouldn't have been exceptions into typed errors."),(0,r.kt)("h3",{id:"from-logical-failures"},"From logical failures"),(0,r.kt)("p",null,"When working with values or functions that can result in a typed error, we often need to ",(0,r.kt)("em",{parentName:"p"},"recover")," to provide or calculate fallback values.\nTo demonstrate how we can ",(0,r.kt)("em",{parentName:"p"},"recover")," from ",(0,r.kt)("em",{parentName:"p"},"logical failures"),", let's define a simple function that returns our ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," in case the ",(0,r.kt)("inlineCode",{parentName:"p"},"id > 0"),"; otherwise it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'suspend fun fetchUser(id: Long): Either<UserNotFound, User> = either {\n  ensure(id > 0) { UserNotFound("Invalid id: $id") }\n  User(id)\n}\n\nsuspend fun Raise<UserNotFound>.fetchUser(id: Long): User {\n  ensure(id > 0) { UserNotFound("Invalid id: $id") }\n  return User(id)\n}\n')),(0,r.kt)("p",null,"To recover from any errors on a ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value, we can most conveniently use ",(0,r.kt)("inlineCode",{parentName:"p"},"getOrElse"),", since it allows us to ",(0,r.kt)("em",{parentName:"p"},"unwrap")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and provide a fallback value.\nThe same can be done for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," based computation using the ",(0,r.kt)("inlineCode",{parentName:"p"},"recover")," DSL instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun example() {\n  fetchUser(-1)\n    .getOrElse { e: UserNotFound -> null } shouldBe null\n\n  recover({\n    fetchUser(1)\n  }) { e: UserNotFound -> null } shouldBe User(1)\n}\n")),(0,r.kt)("p",null,"Default to ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," is typically not desired since we've effectively swallowed our ",(0,r.kt)("em",{parentName:"p"},"logical failure")," and ignored our error. If that was desirable, we could've used nullable types initially.\nWhen encountering a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," and not being able to provide a proper fallback value, we typically want to execute another operation that might fail with ",(0,r.kt)("inlineCode",{parentName:"p"},"OtherError"),".\nAs a result, our ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," value doesn't get ",(0,r.kt)("em",{parentName:"p"},"unwrapped")," as it did with ",(0,r.kt)("inlineCode",{parentName:"p"},"getOrElse"),", since a different ",(0,r.kt)("em",{parentName:"p"},"logical failure")," might've occurred."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"object OtherError\n\nfun example() {\n  val either: Either<OtherError, User> =\n    fetchUser(1)\n      .recover { _: UserNotFound -> raise(OtherError) }\n  \n  either shouldBe User(1).right()\n\n  fetchUser(-1)\n    .recover { _: UserNotFound -> raise(OtherError) } shouldBe OtherError.left()\n}\n")),(0,r.kt)("p",null,"The type system now tracks that a new error of ",(0,r.kt)("inlineCode",{parentName:"p"},"OtherError")," might have occurred, but we recovered from any possible errors of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserNotFound "),". This is useful across application layers or in the service layer, where we might want to ",(0,r.kt)("inlineCode",{parentName:"p"},"recover")," from a ",(0,r.kt)("inlineCode",{parentName:"p"},"DatabaseError")," with a ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkError")," when we want to load data from the network when a database operation failed.\nTo achieve the same with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," DSL, we need to be inside the context of ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise<OtherError>")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun Raise<OtherError>.recovery(): User =\n  recover({\n    fetchUser(-1)\n  }) { _: UserNotFound -> raise(OtherError) }\n")),(0,r.kt)("admonition",{title:"DSLs everywhere",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Since recovery for both ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," is DSL based, you can also call ",(0,r.kt)("inlineCode",{parentName:"p"},"bind")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," from both.\nThis allows seamless interop between both types when creating programs that can fail and recovering from them.")),(0,r.kt)("h3",{id:"from-exceptions"},"From exceptions"),(0,r.kt)("p",null,"When building applications, we often need to wrap side effects or foreign code, like when interacting with the network or databases.\nWrapping such APIs requires handling the possibility of failure, and we can do so by returning a ",(0,r.kt)("em",{parentName:"p"},"logical failure"),". The question is often, do we need to take into ",(0,r.kt)("strong",{parentName:"p"},"all")," exceptions or just a subset of them?\nThe answer is that it depends on the use case, but, in general, we should try to be as specific as possible and only handle the exceptions that we can recover from or expect.\nHowever, you might want to be more defensive when interacting with improperly defined systems."),(0,r.kt)("p",null,"Let's look at an example where we interact with a database and want to insert a new user. If the user already exists, we want to return a ",(0,r.kt)("em",{parentName:"p"},"logical failure")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"UserAlreadyExists"),". Otherwise, we want to return the newly created user.\nWe again showcase both the code for ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," based computation and see that both are almost the same."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," DSL allows us to wrap foreign functions and capture any ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"T: Throwable")," that might be thrown. It automatically avoids capturing ",(0,r.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core/-non-fatal.html"},"fatal exceptions")," such as ",(0,r.kt)("inlineCode",{parentName:"p"},"OutOfMemoryError"),", or Kotlin's ",(0,r.kt)("inlineCode",{parentName:"p"},"CancellationException"),".\nIt requires two functions, or lambdas, as arguments: One for wrapping our ",(0,r.kt)("em",{parentName:"p"},"foreign code")," and another for resolving the captured ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"T : Throwable"),". In this case, instead of providing a fallback value, we ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," a ",(0,r.kt)("em",{parentName:"p"},"logical failure"),"."),(0,r.kt)("p",null,"We expect ",(0,r.kt)("inlineCode",{parentName:"p"},"SQLException")," since we only ",(0,r.kt)("em",{parentName:"p"},"expect")," it to be thrown and rethrow any other ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),".\nWe can then operate on the captured ",(0,r.kt)("inlineCode",{parentName:"p"},"SQLException")," to check if our insertion failed with a unique violation, and, in that case, we turn it into a ",(0,r.kt)("inlineCode",{parentName:"p"},"UserAlreadyExists")," ",(0,r.kt)("em",{parentName:"p"},"logical failure"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class UserAlreadyExists(val username: String, val email: String)\n\nsuspend fun Raise<UserAlreadyExists>.insertUser(username: String, email: String): Long =\n  catch({\n    UsersQueries.insert(username, email)\n  }) { e: SQLException ->\n    if (e.isUniqueViolation()) raise(UserAlreadyExists(username, email))\n    else throw e\n  }\n")),(0,r.kt)("p",null,"Since we also have ",(0,r.kt)("inlineCode",{parentName:"p"},"raise")," available inside ",(0,r.kt)("inlineCode",{parentName:"p"},"either"),", we can also write the same code using ",(0,r.kt)("inlineCode",{parentName:"p"},"either")," or execute this function inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"either")," block as shown above.\nThis behavior is also available as top-level functionality on ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," itself if you prefer to use that. It can be achieved using ",(0,r.kt)("inlineCode",{parentName:"p"},"catchOrThrow")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"catch")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"mapLeft")," to transform ",(0,r.kt)("inlineCode",{parentName:"p"},"SQLException")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"UserAlreadyExists"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"suspend fun insertUser(username: String, email: String): Either<UserAlreadyExists, Long> =\n  Either.catchOrThrow<SQLException, Long> {\n    UsersQueries.insert(username, email)\n  }.mapLeft { e ->\n    if (e.isUniqueViolation()) UserAlreadyExists(username, email)\n    else throw e\n  }\n")),(0,r.kt)("p",null,"This pattern allows us to turn exceptions we want to track into ",(0,r.kt)("em",{parentName:"p"},"typed errors"),", and things that are ",(0,r.kt)("strong",{parentName:"p"},"truly")," exceptional remain exceptional."),(0,r.kt)("h2",{id:"accumulating-errors"},"Accumulating errors"),(0,r.kt)("p",null,"All the behavior above works similarly to ",(0,r.kt)("inlineCode",{parentName:"p"},"Throwable"),", but in a typed manner. This means that if we encounter a typed error or ",(0,r.kt)("em",{parentName:"p"},"logical failure"),", that error is propagated, and we can't continue with the computation and ",(0,r.kt)("em",{parentName:"p"},"short-circuit"),".\nWhen we need to work with collections, or ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable"),", we often want to accumulate all the errors and not short-circuit. Let's take a look at how we can do this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class NotEven(val i: Int)\n\nfun Raise<NotEven>.isEven(i: Int): Int =\n  i.also { ensure(i % 2 == 0) { NotEven(i) } }\n\nfun isEven2(i: Int): Either<NotEven, Int> =\n  either { isEven(i) }\n")),(0,r.kt)("p",null,"First, we define two functions that return a typed error if the value is not even.\nIf we want to accumulate all the errors, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterable")," to get all the errors, and doing so for ",(0,r.kt)("inlineCode",{parentName:"p"},"(0..10)")," should return the following ",(0,r.kt)("inlineCode",{parentName:"p"},"errors"),"."),(0,r.kt)("admonition",{title:"Non-empty lists",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Since you have potentially more than one failure, the error type in ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," must be some sort of list.\nHowever, we know that if we are not in the happy path, then ",(0,r.kt)("em",{parentName:"p"},"at least one")," error must have occurred.\nArrow makes this fact explicit by making the return type of ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate ")," a ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"Nel")," for short.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"val errors = nonEmptyListOf(NotEven(1), NotEven(3), NotEven(5), NotEven(7), NotEven(9)).left()\n\nfun example() {\n  (1..10).mapOrAccumulate { isEven(it) } shouldBe errors\n  (1..10).mapOrAccumulate { isEven2(it).bind() } shouldBe errors\n}\n")),(0,r.kt)("p",null,"We can also provide custom logic to accumulate the errors, typically when we have custom types.\nBelow, instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"NonEmptyList<NotEven>"),", we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"MyError")," type that builds a String with all the error messages.\nSo we again define two functions that return a typed error if the value is not even."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class MyError(val message: String)\n\nfun Raise<MyError>.isEven(i: Int): Int =\n  ensureNotNull(i.takeIf { i % 2 == 0 }) { MyError("$i is not even") }\n\nfun isEven2(i: Int): Either<MyError, Int> =\n  either { isEven(i) }\n')),(0,r.kt)("p",null,"And we write a small function that combines two values of our typed error into one, appending the error messages."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'operator fun MyError.plus(second: MyError): MyError =\n  MyError(message + ", ${second.message}")\n')),(0,r.kt)("p",null,"We can then simply pass this function to the ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," function, and it will accumulate all the errors into a single ",(0,r.kt)("inlineCode",{parentName:"p"},"MyError")," value using our provided function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val error = MyError("1 is not even, 3 is not even, 5 is not even, 7 is not even, 9 is not even").left()\n\nfun example() {\n  (1..10).mapOrAccumulate(MyError::plus) { isEven(it) } shouldBe error\n  (1..10).mapOrAccumulate(MyError::plus) { isEven2(it).bind() } shouldBe error\n}\n')),(0,r.kt)("h3",{id:"accumulating-different-computations"},"Accumulating different computations"),(0,r.kt)("p",null,"In the example above we are providing one single function to operate on a sequence of elements.\nAnother important and related scenario is accumulating different errors, but each of them coming from different computations.\nFor example, you need to perform validation over the different fields of a form, and accumulate the errors, but each field has different constraints."),(0,r.kt)("p",null,"As a guiding example, let's consider information about a user, where the name shouldn't be empty and the age should be non-negative."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class User(val name: String, val age: Int)\n")),(0,r.kt)("p",null,"It's customary to define the different problems that may arise from validation as a sealed interface:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"sealed interface UserProblem {\n  object EmptyName: UserProblem\n  data class NegativeAge(val age: Int): UserProblem\n}\n")),(0,r.kt)("p",null,"Let's define validation as a ",(0,r.kt)("em",{parentName:"p"},"smart constructor"),", that is, by creating a function which looks like the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," constructor, but performs additional checks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<UserProblem, User> = either {\n      ensure(name.isNotEmpty()) { UserProblem.EmptyName }\n      ensure(age >= 0) { UserProblem.NegativeAge(age) }\n      User(name, age)\n    }\n  }\n}\n")),(0,r.kt)("p",null,"Alas, that implementation stops after the first error. We can see this if we try to validate a ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," with both an empty name and a wrong age."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  User("", -1) shouldBe Left(UserProblem.EmptyName)\n}\n')),(0,r.kt)("p",null,"If you want to gather as many validation problems as possible, you need to switch to ",(0,r.kt)("em",{parentName:"p"},"accumulation"),", as done above with ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate"),".\nWhen each of the validations is different, you should reach to ",(0,r.kt)("inlineCode",{parentName:"p"},"zipOrAccumulate"),": each of the arguments defines one independent validation,\nand the final block defines what to do when all the validations were successful, that is, when no problem was ",(0,r.kt)("inlineCode",{parentName:"p"},"raise"),"d during execution."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"data class User private constructor(val name: String, val age: Int) {\n  companion object {\n    operator fun invoke(name: String, age: Int): Either<NonEmptyList<UserProblem>, User> = either {\n      zipOrAccumulate(\n        { ensure(name.isNotEmpty()) { UserProblem.EmptyName } },\n        { ensure(age >= 0) { UserProblem.NegativeAge(age) } }\n      ) { _, _ -> User(name, age) }\n    }\n  }\n}\n")),(0,r.kt)("p",null,"With this change, the problems are correctly accumulated. Now we can present the user all the problems in the form at once."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'fun example() {\n  User("", -1) shouldBe Left(nonEmptyListOf(UserProblem.EmptyName, UserProblem.NegativeAge(-1)))\n}\n')),(0,r.kt)("admonition",{title:"Error accumulation and concurrency",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In addition to accumulating errors, you may want to perform each of the tasks within ",(0,r.kt)("inlineCode",{parentName:"p"},"zipOrAccumulate")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"mapOrAccumulate")," in parallel.\nArrow Fx features ",(0,r.kt)("a",{parentName:"p",href:"../../coroutines/parallel/#accumulating-typed-errors-in-parallel"},(0,r.kt)("inlineCode",{parentName:"a"},"parZipOrAccumulate")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"parMapOrAccumulate"))," to cover\nthose cases, in addition to ",(0,r.kt)("a",{parentName:"p",href:"../../coroutines/parallel/#integration-with-typed-errors"},(0,r.kt)("inlineCode",{parentName:"a"},"parZip")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"parMap")),"\nwhich follow a short-circuiting approach.")),(0,r.kt)("h2",{id:"transforming-errors"},"Transforming errors"),(0,r.kt)("p",null,"We call this approach ",(0,r.kt)("em",{parentName:"p"},"typed")," errors because at every point the signatures state which is the type of errors that may be raised from some computation. This type is checked when ",(0,r.kt)("inlineCode",{parentName:"p"},".bind"),"ing, which means that you cannot directly consume computation with a given error type within a block with a different one. The solution is to ",(0,r.kt)("em",{parentName:"p"},"transform")," the error, which is achieved using ",(0,r.kt)("a",{parentName:"p",href:"https://apidocs.arrow-kt.io/arrow-core/arrow.core.raise/with-error.html"},(0,r.kt)("inlineCode",{parentName:"a"},"withError")),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val stringError: Either<String, Boolean> = "problem".left()\n\nval intError: Either<Int, Boolean> = either {\n  // transform error String -> Int\n  withError({ it.length }) { \n    stringError.bind()\n  }\n}\n')),(0,r.kt)("p",null,"A very common pattern is using ",(0,r.kt)("inlineCode",{parentName:"p"},"withError"),' to "bridge" validation errors of sub-components into validation errors of the larger value.'),(0,r.kt)("admonition",{title:"Ignoring errors",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In the context of ",(0,r.kt)("a",{parentName:"p",href:"../nullable-and-option"},"nullable and ",(0,r.kt)("inlineCode",{parentName:"a"},"Option")),' you often need to "forget" the error type if consuming more informative types like ',(0,r.kt)("inlineCode",{parentName:"p"},"Either"),". Although you can achieve this behavior using ",(0,r.kt)("inlineCode",{parentName:"p"},"withError"),", we provide a more declarative version called ",(0,r.kt)("inlineCode",{parentName:"p"},"ignoreErrors"),".")),(0,r.kt)("h2",{id:"summary"},"Summary"),(0,r.kt)("p",null,"At this point we can summarize the advantages that typed errors offer over using exceptions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Type Safety:")," Typed errors allow the compiler to find type mismatches early, making it easier to catch bugs before they make it to production. However, with exceptions, the type information is lost, making it more difficult to detect errors at compile-time.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Predictability:")," When using typed errors, the possible error conditions are explicitly listed in the type signature of a function. This makes it easier to understand the possible error conditions and write tests covering all error scenarios.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Composability:")," Typed errors can be easily combined and propagated through a series of function calls, making writing modular, composable code easier. With exceptions, ensuring errors are correctly propagated through a complex codebase can be difficult. Patterns like accumulation, which are at your fingertips using typed errors, become quite convoluted using exceptions.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Performance:")," Exception handling can significantly impact performance, especially in languages that don't have a dedicated stack for exceptions. Typed errors can be handled more efficiently as the compiler has more information about the possible error conditions."))),(0,r.kt)("p",null,"In summary, typed errors provide a more structured, predictable, and efficient way of handling errors and make writing high-quality, maintainable code easier."),(0,r.kt)("p",null,"We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Either")," type to represent a value that can either be a success or a failure, and we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise")," DSL to raise typed errors without ",(0,r.kt)("em",{parentName:"p"},"wrappers"),".\nSince all these functions and builders are built on top of ",(0,r.kt)("inlineCode",{parentName:"p"},"Raise"),", they all seamlessly work together, and we can mix and match them as we please."),(0,r.kt)("p",null,"If you have any questions or feedback, please reach out to us on ",(0,r.kt)("a",{parentName:"p",href:"https://slack-chats.kotlinlang.org/c/arrow"},"Slack")," or ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/arrow-kt/arrow/issues"},"Github"),"."))}u.isMDXComponent=!0}}]);