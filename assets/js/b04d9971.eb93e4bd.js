"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[3195],{58431:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=t(85893),s=t(11151);const o={sidebar_position:5},a="Types and invariants",r={id:"ecosystem/analysis/types",title:"Types and invariants",description:'Classes and interfaces (which we shall collectively refer to as "types") play a crucial role in organizing data in Kotlin. Arrow Analysis builds upon this idea, giving users the ability to attach Boolean expressions related to the data contained in a class. We call those invariants of the type, since the tool enforces those expressions to be true throughout the whole program.',source:"@site/content/docs/ecosystem/analysis/types.md",sourceDirName:"ecosystem/analysis",slug:"/ecosystem/analysis/types",permalink:"/ecosystem/analysis/types",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/ecosystem/analysis/types.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"ecosystemSidebar",previous:{title:"Mutability and loops",permalink:"/ecosystem/analysis/mutability"},next:{title:"Fields and wrappers",permalink:"/ecosystem/analysis/wrappers"}},c={},l=[{value:"Initializers with <code>pre</code> and <code>post</code>",id:"initializers-with-pre-and-post",level:2},{value:"Inheritance",id:"inheritance",level:2},{value:"Implicit pre and post-conditions",id:"implicit-pre-and-post-conditions",level:3},{value:"Post-condition or invariant?",id:"post-condition-or-invariant",level:3},{value:"Interfaces and abstract members",id:"interfaces-and-abstract-members",level:2},{value:"Enumerations",id:"enumerations",level:2}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"types-and-invariants",children:"Types and invariants"}),"\n",(0,i.jsxs)(n.p,{children:['Classes and interfaces (which we shall collectively refer to as "types") play a crucial role in organizing data in Kotlin. Arrow Analysis builds upon this idea, giving users the ability to attach Boolean expressions related to the data contained in a class. We call those ',(0,i.jsx)(n.em,{children:"invariants"})," of the type, since the tool enforces those expressions to be true throughout the whole program."]}),"\n",(0,i.jsxs)(n.p,{children:["The easiest way to introduce invariants is using an ",(0,i.jsx)(n.code,{children:"init"})," block with calls to ",(0,i.jsx)(n.code,{children:"require"})," inside. Those initializers are run regardless of the constructor used to instantiate the class, so they provide the most compact way to declare the invariants."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Positive(val value: Int) {\n  init { require(value > 0) }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The invariant has dual roles with respect to the type. When you ",(0,i.jsx)(n.em,{children:"instantiate"})," the class, the invariant becomes a ",(0,i.jsx)(n.em,{children:"pre-condition"}),". In the example above, to create a ",(0,i.jsx)(n.code,{children:"Positive"})," object, the argument passed as ",(0,i.jsx)(n.code,{children:"value"})," must be greater than 0."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"val positiveExample = Positive(-1)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In any other situation, using an instance of a type brings the invariant into the ",(0,i.jsx)(n.em,{children:"environment"}),". That means that the check can use that additonal information in its reasoning. For example, the analysis knows that from the fact that both ",(0,i.jsx)(n.code,{children:"this"})," and ",(0,i.jsx)(n.code,{children:"other"})," are instances of ",(0,i.jsx)(n.code,{children:"Positive"}),", both ",(0,i.jsx)(n.code,{children:"this.value"})," and ",(0,i.jsx)(n.code,{children:"other.value"})," are positive; hence its addition is positive and the call to the ",(0,i.jsx)(n.code,{children:"Positive"})," constructor is accepted."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun Positive.add(other: Positive) = Positive(this.value + other.value)\n"})}),"\n",(0,i.jsx)(n.p,{children:"In the above case we are using an extension method, but the same applies to functions declared within the class."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Positive(val value: Int) {\n  init { require(value > 0) }\n\n  operator fun plus(other: Positive) = Positive(this.value + other.value)\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Remember that ",(0,i.jsx)(n.code,{children:"init"})," blocks apply to ",(0,i.jsx)(n.em,{children:"every"})," constructor. Arrow Analysis checks that when you delegate to another constructor, the invariants are still respected. For example, the following is rejected, since zero does not serve as a correct ",(0,i.jsx)(n.code,{children:"value"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class Positive(val value: Int) {\n  init { require(value > 0) }\n  \n  constructor() : this(0) { }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Types like ",(0,i.jsx)(n.code,{children:"Positive"})," above are a special case of ",(0,i.jsx)(n.a,{href:"../wrappers",children:"wrappers"}),", a way to attach additional invariants to already existing types (",(0,i.jsx)(n.code,{children:"Int"}),"in this case.)"]}),"\n",(0,i.jsxs)(n.h2,{id:"initializers-with-pre-and-post",children:["Initializers with ",(0,i.jsx)(n.code,{children:"pre"})," and ",(0,i.jsx)(n.code,{children:"post"})]}),"\n",(0,i.jsxs)(n.p,{children:["Whereas ",(0,i.jsx)(n.code,{children:"init"})," blocks are the preferred way to declare invariants, Arrow Analysis provides a more fine-grained approach which can be useful in some cases. Remember that an invariant plays two roles: you need them to be true at instantiation time, and you can count on them at usage time; you can decide for an invariant to have only the first role by using ",(0,i.jsx)(n.code,{children:"pre"})," in an initializer or constructor, and to have only the latter role by using ",(0,i.jsx)(n.code,{children:"post"}),". For example, the definition of ",(0,i.jsx)(n.code,{children:"Positive"})," above could be rewritten as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\nimport arrow.analysis.post\n\nclass Positive(val value: Int) {\n  init { \n    pre(value > 0) { "value must be positive" }\n    post({ this.value > 0 }) { "value is positive" }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The most common scenario for this split is when a secondary constructor enforces additional checks on input arguments. In that case ",(0,i.jsx)(n.code,{children:"pre"})," is used within the constructor."]}),"\n",(0,i.jsx)(n.h2,{id:"inheritance",children:"Inheritance"}),"\n",(0,i.jsxs)(n.p,{children:["Classes and interfaces do not live in a vacuum, in fact they often go into relationships with each other. This brings up the question of the relation of pre and post-conditions between parent and subclasses. To understand how Arrow Analysis approaches this problem, we need to look at the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Liskov_substitution_principle",children:"Liskov Substitution Principle"}),", which roughly states:"]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"B"})," is a subclass of ",(0,i.jsx)(n.code,{children:"A"}),", then we should be able to use ",(0,i.jsx)(n.code,{children:"B"})," (and any of its methods) ",(0,i.jsx)(n.strong,{children:"anywhere"})," we use ",(0,i.jsx)(n.code,{children:"A"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["This translates into the following two guidelines for the case in which ",(0,i.jsx)(n.code,{children:"B"})," overrides a method ",(0,i.jsx)(n.code,{children:"m"})," from class ",(0,i.jsx)(n.code,{children:"A"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The pre-conditions on ",(0,i.jsx)(n.code,{children:"B.m"})," must be ",(0,i.jsx)(n.strong,{children:"weaker"})," than (or equivalent to) those of ",(0,i.jsx)(n.code,{children:"A.m"}),". This ensures that whenever we were calling ",(0,i.jsx)(n.code,{children:"A.m"})," we call ",(0,i.jsx)(n.code,{children:"B.m"})," instead."]}),"\n",(0,i.jsxs)(n.li,{children:["The post-conditions offered by ",(0,i.jsx)(n.code,{children:"B.m"})," must be ",(0,i.jsx)(n.strong,{children:"stronger"})," than (or equivalent to) those of ",(0,i.jsx)(n.code,{children:"A.m"}),". This ensures that any reasoning that relies on ",(0,i.jsx)(n.code,{children:"A.m"})," still works when using ",(0,i.jsx)(n.code,{children:"B.m"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Let's look at a concrete example, and understand why it is rejected."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nopen class A() {\n  open fun f(): Int = 2.post({ it > 0 }) { "greater than 0" }\n}\n\nclass B(): A() {\n  override fun f(): Int = 1.post({ it >= 0 }) { "non-negative" }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["None of ",(0,i.jsx)(n.code,{children:"A.f"})," nor ",(0,i.jsx)(n.code,{children:"B.f"})," declare a pre-condition, so in particular they are equivalent. In the post-condition front, ",(0,i.jsx)(n.code,{children:"A.f"})," declares that the result must be ",(0,i.jsx)(n.em,{children:"strictly"})," greater than 0, whereas ",(0,i.jsx)(n.code,{children:"B.f"})," also allows ",(0,i.jsx)(n.code,{children:"0"})," in its post-condition. This means that the post-condition of ",(0,i.jsx)(n.code,{children:"B.f"})," is weaker than that of ",(0,i.jsx)(n.code,{children:"A.f"}),", and the code is rejected."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-plain",children:"e: post-condition `greater than 0` from overridden member is not satisfied\n"})}),"\n",(0,i.jsx)(n.h3,{id:"implicit-pre-and-post-conditions",children:"Implicit pre and post-conditions"}),"\n",(0,i.jsxs)(n.p,{children:["Whenever a method in a type declares pre and post-conditions, but an overriden member does declare any, they are ",(0,i.jsx)(n.em,{children:"implicitly"})," inherited. This allows us to introduce a contract in a parent class or interface, and ensure that all their children satisfy that rule."]}),"\n",(0,i.jsxs)(n.p,{children:["This slight modification of the example above is also rejected. In this case the post-condition ",(0,i.jsx)(n.code,{children:"result > 0"})," is implicitly inherited by ",(0,i.jsx)(n.code,{children:"B.f"}),". However, the result value computed in its body, ",(0,i.jsx)(n.code,{children:"0"}),", does not satisfy that post-condition."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nopen class A() {\n  open fun f(): Int = 2.post({ it > 0 }) { "greater than 0" }\n}\n\nclass B(): A() {\n  override fun f(): Int = 0\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"There are exceptions to this implicit inheritance: initializer blocks and constructors. Meaning that invariants which hold in the parent class must be guaranteed in the subclasses, in the most extreme case by repeating those invariants."}),"\n",(0,i.jsx)(n.h3,{id:"post-condition-or-invariant",children:"Post-condition or invariant?"}),"\n",(0,i.jsxs)(n.p,{children:["When designing a hierarchy of classes, we often need to decide whether we attach information about a property as an invariant of each class, or as a post-condition of the property. For example, this is another way in which we could have declared our ",(0,i.jsx)(n.code,{children:"Positive"})," class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nclass Positive(private n: Int) {\n  init { pre(n > 0) }\n  \n  val value: Int = n.post({ it > 0 }) { "value is positive" }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"The differences between both ways are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Invariants become available whenever we have an instance of that type, whereas post-conditions are only brought into consideration when we ",(0,i.jsx)(n.em,{children:"use"})," the property somewhere in the code. On that respect, invariants are slightly more powerful than post-conditions."]}),"\n",(0,i.jsxs)(n.li,{children:["Post-conditions are ",(0,i.jsx)(n.em,{children:"inherited"}),", but invariants are not. As a consequence, if the property has some contract as part of the hierarchy, it should be declared as post-condition."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"interfaces-and-abstract-members",children:"Interfaces and abstract members"}),"\n",(0,i.jsxs)(n.p,{children:["We have mentioned that by using pre and post-conditions we have enforce a particular contract on a hierarchy of types. This holds also for ",(0,i.jsx)(n.code,{children:"interfaces"}),", but we need to use a different way to attach those pre- and postconditions, since abstract members don't have a body where we can include ",(0,i.jsx)(n.code,{children:"pre"})," and ",(0,i.jsx)(n.code,{children:"post"})," blocks. The solution is to use the ",(0,i.jsx)(n.code,{children:"@Law"})," annotation (you can learn more about it in the section about integration with 3rd-party libraries.)"]}),"\n",(0,i.jsxs)(n.p,{children:["Following our example, this is how we would declare ",(0,i.jsx)(n.code,{children:"A"})," as an interface while keeping the promise of ",(0,i.jsx)(n.code,{children:"f"})," always returning a positive number. We add an additional member marked with the ",(0,i.jsx)(n.code,{children:"@Law"})," annotation, and whose body consists ",(0,i.jsx)(n.strong,{children:"only"})," of ",(0,i.jsx)(n.code,{children:"pre"})," and ",(0,i.jsx)(n.code,{children:"post"})," blocks and a call to the function we want to decorate (the name is irrelevant, but we often use ",(0,i.jsx)(n.code,{children:"method_Law"})," or something similar.)"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.Law\nimport arrow.analysis.post\n\ninterface A {\n  fun f(): Int\n\n  @Law fun f_Law(): Int =\n    f().post({ it > 0 }) { "greater than 0" }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"enumerations",children:"Enumerations"}),"\n",(0,i.jsxs)(n.p,{children:["Everything we have described above holds without change for enumerations. However, note the special syntax you need to follow with ",(0,i.jsx)(n.code,{children:"enum class"})," in Kotlin: you first must introduce all the cases, then write a semicolon (",(0,i.jsx)(n.code,{children:";"}),"), and only then you are allowed to write an ",(0,i.jsx)(n.code,{children:"init"})," block."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'enum class Color(val rgb: Int) {\n  RED(0xFF0000),\n  GREEN(0x00FF00),\n  BLUE(0x0000FF); // <-- the semicolon!\n\n  init {\n    require(rgb != 0) { "no zero color" }\n  }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var i=t(67294);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);