"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[3157],{77270:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>c});var i=s(85893),r=s(11151);const t={sidebar_position:5},a="Prisms & Isos",o={id:"learn/immutable-data/prism-iso",title:"Prisms & Isos",description:"Prisms extend the capabilities of optics from merely inspecting or modifying",source:"@site/content/docs/learn/immutable-data/prism-iso.md",sourceDirName:"learn/immutable-data",slug:"/learn/immutable-data/prism-iso",permalink:"/learn/immutable-data/prism-iso",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/learn/immutable-data/prism-iso.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"learnSidebar",previous:{title:"Traversals",permalink:"/learn/immutable-data/traversal"},next:{title:"Reflection",permalink:"/learn/immutable-data/reflection"}},l={},c=[{value:"(Sealed) class hierarchies",id:"sealed-class-hierarchies",level:2},{value:"Constructing values",id:"constructing-values",level:3},{value:"Isomorphisms",id:"isomorphisms",level:2},{value:"Value classes",id:"value-classes",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"prisms--isos",children:"Prisms & Isos"}),"\n",(0,i.jsxs)(n.p,{children:["Prisms extend the capabilities of optics from merely inspecting or modifying\nvalues to ",(0,i.jsx)(n.em,{children:"constructing"})," them. This is very useful when using sealed hierarchies\nor value classes."]}),"\n",(0,i.jsx)(n.admonition,{title:"In a rush?",type:"info",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Prisms extend optionals to represent class hierarchies."}),"\n",(0,i.jsxs)(n.li,{children:["Isos extend prisms (and lenses) to represent lossless conversion between types.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"One important case is given by value classes."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["To build a value use ",(0,i.jsx)(n.code,{children:"reverseGet"}),"."]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"sealed-class-hierarchies",children:"(Sealed) class hierarchies"}),"\n",(0,i.jsxs)(n.p,{children:["The following is an example of ",(0,i.jsx)(n.code,{children:"User"})," where\nwe have two options: a person or a company."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"import arrow.optics.*\n\n@optics sealed interface User {\n  companion object\n}\n@optics data class Person(val name: String, val age: Int): User {\n  companion object\n}\n@optics data class Company(val name: String, val country: String): User {\n  companion object\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The Arrow Optics plug-in generates two optics within ",(0,i.jsx)(n.code,{children:"User"}),", namely\n",(0,i.jsx)(n.code,{children:"User.person"})," and ",(0,i.jsx)(n.code,{children:"User.company"}),". These optics only focus on a value when\nit has the corresponding type. This is often used to modify a value only\nfor a specific type in the hierarchy, leaving the rest untouched. This is\nprecisely what happens in the function below:\n",(0,i.jsx)(n.code,{children:"Person"}),"s get their age incremented, but ",(0,i.jsx)(n.code,{children:"Company"}),"s remains unchanged."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun List<User>.happyBirthday() =\n  map { User.person.age.modify(it) { age -> age + 1 } }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Several of the types in Arrow Core fit this pattern of sealed hierarchy, and\nArrow Optics contains optics matching those. One example is ",(0,i.jsx)(n.code,{children:"Either"}),", with\nthe corresponding ",(0,i.jsx)(n.code,{children:"left"})," and ",(0,i.jsx)(n.code,{children:"right"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"constructing-values",children:"Constructing values"}),"\n",(0,i.jsxs)(n.p,{children:["The optics we're discussing in this section provide an added feature: they can\nbe used to ",(0,i.jsx)(n.em,{children:"create"})," new values in addition to inspecting or modifying existing\nones. Optionals with this power are called ",(0,i.jsx)(n.strong,{children:"prisms"}),", and this power is\navailable as the ",(0,i.jsx)(n.code,{children:"reverseGet"})," operation."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, we can build a ",(0,i.jsx)(n.code,{children:"Left"})," value using the corresponding prism\ninstead of the constructor."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun example() {\n  val x = Prism.left<Int, String>().reverseGet(5)\n  x shouldBe Either.Left(5)\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"isomorphisms",children:"Isomorphisms"}),"\n",(0,i.jsxs)(n.p,{children:["Prisms allow you to construct values, but still the top of the hierarchy\nmay have different subclasses, so access still required as optional.\nFor example, you can construct an ",(0,i.jsx)(n.code,{children:"Either"})," from ",(0,i.jsx)(n.code,{children:"Right"}),", but when you\ninspect an ",(0,i.jsx)(n.code,{children:"Either"}),", ",(0,i.jsx)(n.code,{children:"Left"})," is also a possibility. There are some cases\nwhen the conversion between two types is lossless: we can go back and forth\nwithout any chance of failure on inspection. We say that there is an\n",(0,i.jsx)(n.em,{children:"isomorphism"})," between those types; for that reason the corresponding optic\nis called an ",(0,i.jsx)(n.strong,{children:"iso"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, we can move between ",(0,i.jsx)(n.code,{children:"Option<String>"})," and ",(0,i.jsx)(n.code,{children:"Either<Unit, String>"}),"\nwithout loss of information. We convert from ",(0,i.jsx)(n.code,{children:"Some"})," to ",(0,i.jsx)(n.code,{children:"Right"}),", and from\n",(0,i.jsx)(n.code,{children:"None"})," to ",(0,i.jsx)(n.code,{children:"Left"}),", and vice versa. There's no loss of information because\n",(0,i.jsx)(n.code,{children:"Unit"})," is an ",(0,i.jsx)(n.code,{children:"object"}),", so there's a single instance which may appear in the\n",(0,i.jsx)(n.code,{children:"Left"})," value."]}),"\n",(0,i.jsx)(n.admonition,{title:"Iso = Prism + Lens",type:"tip",children:(0,i.jsxs)(n.p,{children:["You can see an iso as a prism where ",(0,i.jsx)(n.code,{children:"get"})," always succeeds,\nor as a lens which also supports the ",(0,i.jsx)(n.code,{children:"reverseGet"})," operation."]})}),"\n",(0,i.jsx)(n.h3,{id:"value-classes",children:"Value classes"}),"\n",(0,i.jsxs)(n.p,{children:["One important case in which lossless conversion is possible is given\nby ",(0,i.jsx)(n.a,{href:"https://kotlinlang.org/docs/inline-classes.html",children:"value (or inline) classes"}),",\nwhich wrap a single value as a distinct type. This kind of classes are\nvery useful to ",(0,i.jsx)(n.a,{href:"../../design/domain-modeling/",children:"model your domain accurately"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@optics data class Person(val name: String, val age: Age) {\n  companion object\n}\n\n@JvmInline @optics value class Age(val age: Int) {\n  companion object\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since isos are also lenses, you can still use the syntax from ",(0,i.jsx)(n.a,{href:"../lens/",children:"the latter"}),"\nto access the value contained in the class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'fun Person.happyBirthday(): Person =\n  Person.age.age.modify(this) { it + 1 }\n\nfun example() {\n  val p = Person("me", Age(29))\n  p.happyBirthday().age shouldBe Age(30)\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>a});var i=s(67294);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);