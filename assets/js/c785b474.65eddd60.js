"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[3670],{3982:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=t(85893),o=t(11151);const i={sidebar_position:3},r="Control operators",a={id:"ecosystem/analysis/control",title:"Control operators",description:"When dealing with pre-conditions, the environment in which a call takes place is very important. You introduce new information in the environment every time you use a control operator like if or when. For example, the following is accepted by Arrow Analysis, when you manually checking whether the size of the list is enough for getin the right value:",source:"@site/content/docs/ecosystem/analysis/control.md",sourceDirName:"ecosystem/analysis",slug:"/ecosystem/analysis/control",permalink:"/ecosystem/analysis/control",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/ecosystem/analysis/control.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"ecosystemSidebar",previous:{title:"Pre and post-conditions",permalink:"/ecosystem/analysis/conditions"},next:{title:"Mutability and loops",permalink:"/ecosystem/analysis/mutability"}},l={},c=[{value:"Unreachable code",id:"unreachable-code",level:2},{value:"No higher-order support",id:"no-higher-order-support",level:2},{value:"Scope functions",id:"scope-functions",level:3},{value:"Null safety",id:"null-safety",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"control-operators",children:"Control operators"}),"\n",(0,s.jsxs)(n.p,{children:["When dealing with pre-conditions, the ",(0,s.jsx)(n.em,{children:"environment"})," in which a call takes place is very important. You introduce new information in the environment every time you use a control operator like ",(0,s.jsx)(n.code,{children:"if"})," or ",(0,s.jsx)(n.code,{children:"when"}),". For example, the following is accepted by Arrow Analysis, when you manually checking whether the ",(0,s.jsx)(n.code,{children:"size"})," of the list is enough for ",(0,s.jsx)(n.code,{children:"get"}),"in the right value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <A> List<A>.firstOr(default: A) =\n  if (this.size > 0) this.get(0) else default\n"})}),"\n",(0,s.jsx)(n.p,{children:"If your check is not strong enough (or wrong altogether), the error message provides additional information about what is known in that branch. For example, suppose you've accidentally switched the order of the branches above:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <A> List<A>.firstOr(default: A): A =\n  if (this.size > 0) default else this.get(0)\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"e: Example.kt: (2, 35): pre-condition `index within bounds` is not satisfied in `get(0)`\n  -> unsatisfiable constraint: `((0 >= 0) && (0 < this.size))`\n  -> in branch: ( ! this.size > 0), cond17\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This tells you that at that point you know that the ",(0,s.jsx)(n.code,{children:"size"})," is not greater than 0 (note the ",(0,s.jsx)(n.code,{children:"!"}),' at the beginning of the expression). Unfortunately, sometimes "garbage" formulae (such as ',(0,s.jsx)(n.code,{children:"cond17"}),") above appear in the output. We are working on ways to prune these useless constraints, in the time being just ignore them."]}),"\n",(0,s.jsxs)(n.p,{children:["The environment is also important when checking post-conditions. Whenever you have some branching operations, like ",(0,s.jsx)(n.code,{children:"if"})," or ",(0,s.jsx)(n.code,{children:"when"}),", the post-condition is checked on ",(0,s.jsx)(n.strong,{children:"each"})," branch ",(0,s.jsx)(n.strong,{children:"separately"}),", even when the ",(0,s.jsx)(n.code,{children:"post"})," appears as part of a common expression. This allows Arrow Analysis to accept the following, in which whether the result is non-negative depends on the prior check over ",(0,s.jsx)(n.code,{children:"n"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nfun absoluteValue(n: Int): Int = when {\n  n < 0  -> -n\n  n == 0 -> 0\n  else   -> n\n}.post({ it >= 0 }) { "result >= 0" }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"unreachable-code",children:"Unreachable code"}),"\n",(0,s.jsxs)(n.p,{children:["Being aware of the environment makes Arrow Analysis able to detect some cases of unreachable code. Here's a simple (but not very useful) example, in which we can guarantee that ",(0,s.jsx)(n.code,{children:"1"})," is never returned because the case ",(0,s.jsx)(n.code,{children:"x < 0"})," cannot arise thanks to the pre-condition."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\n\nfun boo(x: Int): Int {\n  pre(x > 0) { "x must be positive" }\n  return if (x < 0) 1 else 2\n}\n'})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plain",children:"e: unreachable code due to conflicting conditions: x < 0, (x == x), (0 == 0), (x < 0 == (x < 0)), (x > 0)\n  -> main function body\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This is another case in which we continue working on pruning useless information from the error messages. But you can see that ",(0,s.jsx)(n.code,{children:"x < 0"})," and ",(0,s.jsx)(n.code,{children:"x > 0"})," appear in the list, and those two expressions together are inconsistent -- that is, there's no way for a value to satisfy both."]}),"\n",(0,s.jsx)(n.p,{children:"Arrow Analysis detects unreachable code in a best-effort basis. Conflicts may arise not only between pre-conditions and conditionals, but also between several conditionals, and even between the post-conditions of a function and its environment."}),"\n",(0,s.jsx)(n.h2,{id:"no-higher-order-support",children:"No higher-order support"}),"\n",(0,s.jsxs)(n.p,{children:["Arrow Analysis is not able to propagate information via higher-order functions. For example, if you ",(0,s.jsx)(n.code,{children:"map"})," the ",(0,s.jsx)(n.code,{children:"absoluteValue"})," function defined above over a list of numbers, the knowledge that ",(0,s.jsx)(n.em,{children:"each"})," element of the list is non-negative is not represented within the system. The following is rejected, for example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nval okButRejected = listOf(-1).map { absoluteValue(it) }.first()\n  .post({ it >= 0 }) { "result is non-negative" }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This does not mean that the tool is useless on such operations. In this case, we can still express the fact that the size is maintained by ",(0,s.jsx)(n.code,{children:"map"}),", since that condition does ",(0,s.jsx)(n.em,{children:"not"})," depend on the transformation function. As a result, the following is accepted since Arrow Analysis tracks the length of the list through ",(0,s.jsx)(n.code,{children:"map"})," and can see that the call to ",(0,s.jsx)(n.code,{children:"first()"})," is correct."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"val ok = listOf(-1).map { absoluteValue(it) }.first()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"scope-functions",children:"Scope functions"}),"\n",(0,s.jsxs)(n.p,{children:["There are a handful of higher-order functions which play a significant role in Kotlin programs, the so-called ",(0,s.jsx)(n.a,{href:"https://kotlinlang.org/docs/scope-functions.html",children:"scope functions"})," ",(0,s.jsx)(n.code,{children:"let"}),", ",(0,s.jsx)(n.code,{children:"run"}),", ",(0,s.jsx)(n.code,{children:"with"}),", ",(0,s.jsx)(n.code,{children:"apply"}),", and ",(0,s.jsx)(n.code,{children:"also"}),'. Given their importance, Arrow Analysis ships with special support for them: when used with a lambda as second argument, the tool can "look inside" the body during the checks.']}),"\n",(0,s.jsx)(n.p,{children:"This means you can choose whatever code style suits you best. Arrow Analysis can handle local variables,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\nimport arrow.analysis.post\n\nfun double(n: Int): Int {\n  pre(n > 0) { "n positive" }\n  val z = n + n\n  val r = z + 1\n  return r.post({ it > 0 }) { "result positive" }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"as well as chains of scope functions,"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\nimport arrow.analysis.post\n\nfun double2(n: Int): Int {\n  pre(n > 0) { "n positive" }\n  return (n + n).let { it + 1 }\n    .post({ it > 0 }) { "result positive" }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"null-safety",children:"Null safety"}),"\n",(0,s.jsxs)(n.p,{children:["Arrow Analysis can reason about ",(0,s.jsx)(n.code,{children:"null"})," values, in a similar way as the ",(0,s.jsx)(n.a,{href:"https://kotlinlang.org/docs/null-safety.html",children:"Kotlin compiler does"}),". The Elvis safe call operator ",(0,s.jsx)(n.code,{children:"?."})," is recognized, and in combination with the aforementioned support for scope functions. The tool can handle idiomatic code such as the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\nimport arrow.analysis.post\n\nfun incrementNotNull(x: Int?): Int? {\n  pre((x == null) || (x > 0)) { "x is null or positive" }\n  val y = x?.let { it + 1 }\n  return y.post({ (it == null) || (it > 1) }) { "null or greater than 1" }\n}\n'})})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var s=t(67294);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);