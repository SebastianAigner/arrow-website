"use strict";(self.webpackChunkarrow_website=self.webpackChunkarrow_website||[]).push([[7712],{93114:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var t=i(85893),s=i(11151);const o={sidebar_position:6},a="Fields and wrappers",r={id:"ecosystem/analysis/wrappers",title:"Fields and wrappers",description:"Arrow Analysis supports the addition of invariants to types, but what happens when you already have a type and want to add information relative to it? And when may that situation arise? There are two different features to keep more information: fields and wrapper types.",source:"@site/content/docs/ecosystem/analysis/wrappers.md",sourceDirName:"ecosystem/analysis",slug:"/ecosystem/analysis/wrappers",permalink:"/ecosystem/analysis/wrappers",draft:!1,unlisted:!1,editUrl:"https://github.com/arrow-kt/arrow-website/edit/main/content/docs/ecosystem/analysis/wrappers.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"ecosystemSidebar",previous:{title:"Types and invariants",permalink:"/ecosystem/analysis/types"},next:{title:"3rd-party libraries (Laws)",permalink:"/ecosystem/analysis/laws"}},l={},d=[{value:"Fields",id:"fields",level:2},{value:"Definition of fields",id:"definition-of-fields",level:3},{value:"Inline classes",id:"inline-classes",level:2},{value:"Collections",id:"collections",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"fields-and-wrappers",children:"Fields and wrappers"}),"\n",(0,t.jsxs)(n.p,{children:["Arrow Analysis supports the addition of invariants to types, but what happens when you ",(0,t.jsx)(n.em,{children:"already"})," have a type and want to add information relative to it? And when may that situation arise? There are two different features to keep more information: fields and wrapper types."]}),"\n",(0,t.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,t.jsxs)(n.p,{children:["The declaration of pre and post-conditions may not only talk about the value of the arguments, but also reference their properties, fields, and even some of their functions. This is used, for example, in the contract of the indexing operation of a list, in which we refer to its ",(0,t.jsx)(n.code,{children:"size"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\n\nclass List<T> {\n  val size: Int\n    get() = TODO() // complicated computation\n  \n  fun get(index: Int): T {\n    pre(index >= 0 && index < this.size) { "index within bounds" }\n    // complicated code to get the value\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We use the word ",(0,t.jsx)(n.strong,{children:"field"})," to collectively refer to those elements of an argument we are allowed to refer to in a pre- or post-condition, or an invariant of a mutable variable or type. There are two sources for fields:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Properties and fields, like ",(0,t.jsx)(n.code,{children:"size"})," above."]}),"\n",(0,t.jsxs)(n.li,{children:["Instance or extension methods with ",(0,t.jsx)(n.em,{children:"no"})," arguments, this allows you to use ",(0,t.jsx)(n.code,{children:"isNotEmpty()"})," as a field."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Given the rules above, the following is accepted by Arrow Analysis:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.pre\n\nfun <T> List<T>.first(): T {\n  pre(this.isNotEmpty()) { "list should not be empty" }\n  return this.get(0)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"definition-of-fields",children:"Definition of fields"}),"\n",(0,t.jsxs)(n.p,{children:["Actually, if you think about it, the fact that the previous code snippet is accepted is not obvious at all! There must be an additional reasoning step for Arrow Analysis to understand that is the list is not empty, then calling ",(0,t.jsx)(n.code,{children:"get"})," with ",(0,t.jsx)(n.code,{children:"0"})," as index is allowed, since the precondition for ",(0,t.jsx)(n.code,{children:"get"})," only mentions ",(0,t.jsx)(n.code,{children:"size"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It is very common, though, to have this kind of relationship between properties. Furthermore, many style guidelines suggest to use simpler Boolean predicates like ",(0,t.jsx)(n.code,{children:"isNotEmpty()"})," instead of the longer ",(0,t.jsx)(n.code,{children:"size > 0"}),". To establish this broken link, Arrow Analysis follows this rule:"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["If a field declares ",(0,t.jsx)(n.strong,{children:"no"})," pre-conditions, and a ",(0,t.jsx)(n.strong,{children:"single"})," post-condition of the form ",(0,t.jsx)(n.code,{children:"{ it == SOMETHING }"}),", then ",(0,t.jsx)(n.code,{children:"SOMETHING"})," is taken as the ",(0,t.jsx)(n.strong,{children:"definition"})," of that field."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The tool then deems each usage of the derived field as being equivalent to its definition. In our case, the ",(0,t.jsx)(n.code,{children:"List"})," class would declare the post-condition in ",(0,t.jsx)(n.code,{children:"isNotEmpty"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'import arrow.analysis.post\n\nclass List<T> {\n  fun isNotEmpty(): Boolean {\n    // complicated code\n    return something.post({ this.size > 0 }) { "non-emptiness is size > 0" }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We remark that this definition only applies at the level of Arrow Analysis. The ",(0,t.jsx)(n.em,{children:"implementation"})," of ",(0,t.jsx)(n.code,{children:"isNotEmpty"})," is free to use a more performant algorithm. It's during the reasoning stage within the analysis that we make use of the equivalence with ",(0,t.jsx)(n.code,{children:"size > 0"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"inline-classes",children:"Inline classes"}),"\n",(0,t.jsx)(n.p,{children:"Sometimes there's a particular invariant we repeat over and over in our code. For example, a list not being empty or a number being positive:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'fun average(xs: List<Int>): Int {\n  pre(xs.isNotEmpty()) { "list not empty" }\n  TODO()\n}\n\nfun increment(x: Int): Int {\n  pre(x > 0) { "non-negative" }\n  return (x + 1).post({ it > 0 }) { "positive" }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"In those cases it might be worth defining a new type where the invariant is encoded once and for all. Here we show those types corresponding to non-empty lists and positive numbers:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'@JvmInline\nvalue class NonEmptyList<A>(val value: List<A>) {\n  init { require(value.isNotEmpty()) { "not empty" } }\n}\n\n@JvmInline\nvalue class Positive(val value: Int) {\n  init { require(value > 0) { "positive" } }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["That way your pre- and post-conditions are encoded in the types themselves. Alas, in many cases you need to access the underlying ",(0,t.jsx)(n.code,{children:"value"})," or apply the constructor manually."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun average(xs: NonEmptyList<Int>): Int = TODO()\n\nfun increment(x: Positive): Positive {\n  return Positive(x.value + 1)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The good news is that the performance won't suffer. The ",(0,t.jsx)(n.code,{children:"@JvmInline value"})," at the beginning of the ",(0,t.jsx)(n.code,{children:"NonEmptyList"})," and ",(0,t.jsx)(n.code,{children:"Positive"})," classes declare those as ",(0,t.jsx)(n.a,{href:"https://kotlinlang.org/docs/inline-classes.html",children:"inline classes"}),'. The Kotlin compiler substituted ("inlines") any usage of inline classes by their underlying value, avoiding any additional heap allocations.']}),"\n",(0,t.jsx)(n.h2,{id:"collections",children:"Collections"}),"\n",(0,t.jsx)(n.p,{children:"Declaring wrappers to encode invariants become increasingly important when working with collection types (lists, sets, maps). Imagine we want to define a function which increments a list of positive values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// previous version of increment\nfun increment(x: Int): Int {\n  pre(x > 0) { "non-negative" }\n  return (x + 1).post({ it > 0 }) { "positive" }\n}\n\nfun List<Int>.example() = map { increment(it) }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This will not work, as the analysis cannot guarantee that the value passed to ",(0,t.jsx)(n.code,{children:"increment"})," inside ",(0,t.jsx)(n.code,{children:"map"})," is indeed positive. Alas, there is no way to define a pre-condition which talks about ",(0,t.jsx)(n.em,{children:"all the elements"})," in the list (technically, that would involve quantifiers, and this is not supported by the logic in Arrow Analysis.) The solution is to use the corresponding wrapper type:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun List<Positive>.example() = map { increment(it.value) }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that in this case we didn't have to change our definition of ",(0,t.jsx)(n.code,{children:"increment"})," to take ",(0,t.jsx)(n.code,{children:"Positive"})," values. Instead, by unwrapping with ",(0,t.jsx)(n.code,{children:"it.value"})," the condition ",(0,t.jsx)(n.code,{children:"it.value > 0"})," becomes available to the analysis, making the call to ",(0,t.jsx)(n.code,{children:"increment"})," correct."]}),"\n",(0,t.jsxs)(n.p,{children:["One important pattern in this case is the replacement of ",(0,t.jsx)(n.code,{children:"filter"}),"s with operations that introduce the wrapper types. For example, the following is not accepted by Arrow Analysis, because it is unaware of the predicate in ",(0,t.jsx)(n.code,{children:"filter"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun moreExample(xs: List<Int>) = xs.filter { it > 0 }.example()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This case can be worked around by replacing ",(0,t.jsx)(n.code,{children:"filter"})," with ",(0,t.jsx)(n.code,{children:"mapNotNull"}),". Instead of simply removing the undesired elements, we also wrap the good ones in ",(0,t.jsx)(n.code,{children:"Positive"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun moreExample(xs: List<Int>) = xs.mapNotNull {\n  if (it > 0) Positive(it) else null\n}.example()\n"})}),"\n",(0,t.jsxs)(n.p,{children:['In the future we aim to introduce support for attaching invariants to types "on the spot". Other analyzers, like ',(0,t.jsx)(n.a,{href:"https://ucsd-progsys.github.io/liquidhaskell-blog/",children:"LiquidHaskell"}),", support this features by means of ",(0,t.jsx)(n.a,{href:"http://ucsd-progsys.github.io/liquidhaskell-tutorial/Tutorial_03_Basic.html",children:(0,t.jsx)(n.em,{children:"refinement types"})}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>r,a:()=>a});var t=i(67294);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);